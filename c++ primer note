
1.引用即是别名。定义时必须初始化。

    const引用可以绑定到不同但相关类型的对象，非const引用不能绑定到不同类型的引用。

2.const限定符：

    const对象定义时需要被初始化。
 
    const对象默认为文件局部变量:全局作用域定义的const对象作用级别是文件级的。

3.标准库 vector(长度可扩展)，iterator,bitset(专门的位操作类).

4.void*指针可以保存任何类型对象的地址。void*指针只支持几种有限的操作：

    与另一指针比较；

    向函数传递void*指针，或从函数返回void*指针；

    给另一个void*指针复制；

    不允许void*指针操作它所指向的对象。

5.指针和const限定符。

    const double * cptr;    //理解为(自以为指向const对象的指针更准确)指针指向的对象不可通过该指针来改变

    int errNbr=0;
    int *const curErr = &errNbr;    //指针本身不能被修改    
    

    不能用void*指针保存const对象的地址，必须用const void*指针指向const对象。

6.c风格字符串头文件 <cstring>.

7.创建动态数组:

    int *pia new int[10]; 释放 delete [] pia;  //遗漏[]不会报错，但是运行出错 
    string *spa = new string[10];

8.显示转换，也叫强制类型转换。

    const_cast:转换掉表达式的const性质.

    dynamic_cast：支持运行时识别指针或引用所指向的对象。18.2节介绍

    static_cast编译器隐式执行的任何类型转换都可以由static_cast显示完成：

        double d = 97.0；

        char ch = static_cast<char>(d);

    reinterpret_cast:重解释本质上依赖机器，程序员要完全理解数据类型和编译器

        int *ip;

        char *pc = reinterpret_cast<char*>(ip);


9.try...catch:需要进一步了解。

10.标准异常。

11.函数：引用形参，直接关联到其所绑定的形参，而非副本

    bool isshorter(const string &s1, const string &s2)    //只读不修改用const引用
   {
        return s1.size() < s2.size();
   }

12.处理命令行选项：int main(int argc, char *argv[]){...};

13.返回引用时没有复制返回值，返回引用的函数反回的是左值。千万不要返回局部对象的指针。

14.默认实参:通过给形参表中的形参提供明确的初始值来指定。程序员可以为一个多个形参定义默认值。

如果有一个形参具有默认实参，那么他后面所有的形参都必须有默认实参。
 	
string screeninit(string::size_type height = 24,string::size_type width = 80,char background = '');

    1.默认实参可以使任何适当类型的表达式.

    2.在一个文件中，只能为一个形参指定一次默认实参。     

15.类成员函数。

   1.每个函数都有一个隐含的、额外的形参this指针(static成员函数除外)。

   2.构造函数可以被重载.与其他函数一样，构造函数有名字、形参表、函数体.此外还可以有一个初始化列表。
 
   3.构造函数初始化列表：必须用到初始化列表的情况：没有默认构造函数的类类型成员，以及const或者引用类型成员。

   4.初始化列表的初始化顺序不是以列表的顺序，而是以被定义的顺序来初始化的。所以应该以声明的顺序来写初始化列表。
   
   5.初始化是可以使任意表达式.Sales_item(const std::string &book,int cnt,double price,):isbn(book),units_sold(cnt),

        revenue(cnt*price) {}

   6.类类型成员初始化.Sales_item():isbn(10,'9'),unit_sold(0),revenue(0.0){}


16.隐式类类型转换：
  
    可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。

    1.抑制由构造函数定义的隐式转换。

    可以通过将构造函数声明为explicit(只用在类内),来防止在需要隐式转换的上下文中使用构造函数。

    class Sales_item{
        public：
            // default argument for book is the empty string
            explicit Sale_item(const std::string &book =""):isbn(book),units_sold(0){}
    }


    item.same_isbn(null_book);   //error
    item.same_isbn(cin);    //error

    item.same_isbn(Sales_item(null_book));
    item.same_isbn(Sales_item(cin));
    
    note：除非有明显的理由想要定义隐式转换，否则单形参构造函数应该为explicit。
        
    将构造函数设置为explicit可以避免错误。

17.类成员的显示初始化。

    struct Data
    {
        int ival；
        char* ptr；
    }

    Data Val{1024，“Anna”}

    缺点：1.需要类的全体成员都是public.

          2.将初始化每个对象的每个成员的负担放在程序员身上。易错。

          3.如果增删成员，必须更新每一处初始化的地方。


18.友元。解决允许特定的非成员函数访问一个类的私有成员的问题，同时仍然阻止一般的访问。

    1.可以另外一个类声明为友元。

    2.可以其他类的成员函数声明成友元。

    3.要先声明类，然后才能把他们用作友元。

19. static 类成员。
    

    1.对于特定类类型的全体对象，提供一个全局、所有对象可访问的成员。

    2.static 函数没有this指针，所以也不能声明为const。static成员是类的组成部分但不是任何对象的组成部分。

    3.static 数据成员可以声明为任意类型：常量、引用、数组、类。

    4.static 数据成员必须在类定义体的外部定义。它不通过构造函数初始化，而应该定义时初始化。    

    5.特殊的整型 const static成员，可以向普通数据成员一样可以在类的定义体中初始化。


************* 复制控制 ************* 

每种类型定义了创建该类型的对象时发生什么---构造函数

类型还能控制复制、赋值或者撤销该类型的对象：

    复制构造函数:是一种特殊的构造函数，具有单个形参，该形参是对该类类型的引用。

定义一个新对象并用一个同类型的对象对他初始化时，将显式使用复制构造函数。

    当将该类型的对象传递给函数或从函数返回该类型对象时，将隐式使用复制构造函数。

    赋值操作符：如果我们没有编写，编译器将为我们合成一个。

    析构函数：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。

用于释放对象时构造或在对象的生命周期中所获取的资源。

    复制构造函数、赋值操作符和析构函数总称复制控制。编译器自动实现这些操作，但类也可以定义自己的版本。

1.复制构造函数可用于：

    根据另一个同类型的对象显示或隐式的初始化一个对象。

    复制一个对象，将他作为实参传给一个函数。

    从函数返回时复制一个对象。

    初始化顺序容器中的元素。

    根据元素初始化式列表初始化数组元素。

    如下： string null_book = "9-99-999";    // copy-initialization:创建一个临时对象，并用这个对象初始化新对象。
           string dots(10,'.');              // direct-initi..
           string empty_copy = string();     // copy-init..
           string empty_direct;              // direct-initi..

    形参与返回值： string make_plural(size_t ,const string&, const string&);

    初始化容器元素：vector<string> svec(5);

    构造函数与数组元素：对于类类型数组，如果没有提供初始化式，则将用默认构造函数初始化每个元素。然而，如果是用常规的花括号

括住的数组初始化列表提供初始化式，则应使用复制构造函数来初始化每个元素。    


2.合成的复制构造函数：如果没有定义复制构造函数，编译器就会为我们合成一个。

    合成复制构造函数的行为是：执行逐个成员的初始化，将新对象初始化为原对象的副本。(成员含有指针时，不再用合成的。。)

    所谓逐个成员，指的是编译器将现有对象的每个非static成员，一次复制到正在创建的对象。

合成复制构造函数也将复制数组的每一个成员。

3.定义自己的复制构造函数；

    class Foo{
        public:
            Foo();    // default constructor;
            Foo(const Foo&);    // copy constructor;也可以设置成非const引用类型
    };

4.禁止复制。

    有些类需要完全禁止复制。

    1.将复制构造函数设置为private

    2.如果需要连友元和成员都不能复制，就可以声明一个private复制构造函数单不对其定义。

声明而不定义成员函数是合法的，使用未定义的成员变量在编译时导致链接失败。


**************************

赋值操作符：Sales_item trans, accum;

            trans = accum;

与复制构造函数一样，如果类没有定义自己的复制操作符，编译器会合成一个。

operator=函数，我们可以对赋值进行定义。像任何其他的函数一样，操作符函数有一个返回值和形参表。

形参表必须具有与该操作符操作数数目相同的形参。赋值是二元运算，所以操作符函数应有2个形参。第一个

对应左操作数，第二个对应右操作数。

  例如： class Sales_item{
        public:
        // oterh members asa before
        //
        Sales_item& operator=(const Sales_item &);
    };

  合成赋值操作符与合成复制构造函数的操作类似。执行逐个成员赋值。返回对左操作数的引用。

  // 合成复制操作符运算大概等价于

  Sales_item& Sales_item::operator=(const Sales_item &rhs)
  {
     isbn = rhs.isbn;
     units_sold = rhs.units_sold;
     revenue = rhs.revenue;
     return *this;
  }  


******************************

析构函数：

    完成所需的资源的回收，作为类构造函数的补充。

    撤销类对象时会自动调用析构函数。

    只有删除指向动态分配对象的指针或实际对象超出作用域时，才会运行析构函数。 

一般不需要显示的析构函数：如果需要析构函数，则他也需要赋值操作符和复制构造函数。

1.合成析构函数与复制构造函数或赋值操作符不同，编译器总是为我们合成一个析构函数。

    合成的析构函数按对象创建的逆序撤销每个非static成员。合成析构函数并不删除指针成员所指向的对象。

    没有分配资源不需要自己写一个析构函数。

class Sales_item{
    public:
        ~Sales_item(){}
}



*****************

智能指针。。。C++建议使用标准库，而减少指针使用。

*****************


重载操作符与转换

    1.重载的操作符名。

    2.重载操作符必须具有一个类类型的操作数。即内置类型操作符不能重定义。

    3.优先级和结合性是固定的。

    4.不再具备短路求值特性。

    5.可以重载成类成员与非成员。作为类成员的重载函数其形参看起来比操作数数目少1。

作为成员函数的操作符有一个隐含的this形参，限定为第一个操作数。

    一般将算数和关系操作符定义为非成员函数，而将复制操作符定义为成员。
   
    Sales_item& Sales_item::operator+=(const Sales_item &);

    Sales_item operator+(const Sales_item &, const Sales_item & );

操作符重载和友元关系:

    操作符定义为非成员函数时，通常必须将他们设置为所操作类的友元。

    class Sales_item {
        friend std::istream& operator>>(std::istream&, Sales_item&);
        friend std::ostream& operator<<(std::ostream&, Sales_item&);
        public:
            Sales_item& operator+=(const Sales_item&, const Sales_item&);
    };

    Sales_item operator+(const Sales_item&, const Sales_item&);

使用 cout << item1+item2 << endl; 或者

     cout << operator+(item1,item2) << endl;


重载操作符设计：

    1.不要重载有内置含义的操作符。

    2.大多数操作符对类对象没有意义。

    3.如果提供了算术操作符做好也提供复合赋值操作符。

    4.相等和关系操作符。如果定义了<操作符，最好也同时定义==和>操作符。如:sort算法使用<,而find算法使用==操作符。

如果定义了相等操作符，也应该定义!=.如果定义了<,则他可能应该定义全部4个操作符(>,>=,<,<=)。

    5.选择成员或者非成员的实现。一些经验原则：

        赋值(=),下标([])、调用( () )和成员访问箭头(->)定义为类成员。否则会编译错误。

        符合复制操作符通常定义为类的成员。不这样做也不会报错。

        改变对象装填与给定类型紧密联系的其他一些操作符，如自增、自减和解引用，通常定义为类成员。

        对称的操作符，如算术操作符、相等操作符、关系操作符和未操作符，最好定义为普通非成员函数。

********************
    操作符对象

    标准库定义的函数对象：
        plus<type>
        minus<type>
        multiplies<type>...

    函数对象的函数适配器：

        1.绑定器。

有两种：bind1st, bind2nd ???

        2.求反器。???
********************

转换与类类型。

    可用一个实参调用的非explicit构造函数定义一个隐式转换。
    
    转换为什么有用？？？
   
    1.支持混合类型表达式。

    2.减少所需操作符的数目。

转换操作符是一种特殊的类成员函数。他定义将类类型值转变为其他类型值得转换。

    class Smallint{
        public:
            Smallint(int i=0):val(i){}
        operator int() const {return val;}
        private:
            std::size_t val;
    };
    
    转换函数通用形式：operator type（）；

    转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空。
 
    转换函数一般不应该改变被转换的对象。因此，转换操作符通常应定义为const成员
   
    1.使用类类型转换。

        表达式中：
        Smalint si;
        double dval;
        si >= dval;

        在条件中：
        if（si）

        将实参传给函数或从函数返回值：
        int calc(int);
        Smallint si;
        int i = calc(si);

        作为重载操作符的操作数：
        cout << si << endl;

        在显式类型转换中：
        int ival;
        SmallInt si=3.541;  
        ival= static_cast<int>(si)+3;

     2.类类型转换和标准转换。 
        
        被转换的类型不必与所需要的类型完全匹配。必要时可在类类型转换后跟上标准转换以获得想要的类型。
       
        SmallInt si；
        double dval；
        si >= dval;    //si converted to int and then convert to double;

     3.只能应用一个类类型转换   // 不允许多次

        类类型转换之后不能再跟另一个类类型转换。如果需要多个类类型转换，则代码将出错。

        Integral intVal;
        int j = calc(intVal);   //error intVal converted to SmallInt,but SmallInt not converted to int .
    
     4.标准转换可放在类类型转换之前。

        使用构造函数执行意识转换时候，构造函数的形参类型不必与所提供的类型完全匹配。

        vold calc(SmallInt);
        short sobj;
        // sobj promoted from short to int 
        // that int converted to SmallInt through the SmallInt(int)constructor
        calc(sobj);

实参匹配与转换：？？？458页

重载确定和类的实参：？？？

重载、转换和操作符：？？？

     
    面向对象编程
    
1.继承:
    派生类能够继承基类定义的成员。

2.动态绑定:通过基类的引用(或指针)调用虚函数时发生动态绑定。

    引用(或指针)既可以指向基类对象也可以指向派生类对象。用

    引用(或指针)调用的虚函数在运行时确定，被调用的函数是引

    用(或指针)所指对象的实际类型所定义的。

定义基类:首先需要简单的注意继承层次的根类一般都要定义虚析构。

    1.保留字virtual的目的是启动动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定。

    除了构造函数之外，任意非static成员函数都可以是虚函数。保留字只在类内部的成员函数声明

中出现，不能用在类定义体外部出现的函数定义上。

    基类通常应将派生类需要重定义的任意函数定义为虚函数。

    2.protected 它允许派生类访问但仍禁止其他用户访问。

    3.派生类与虚函数：一旦函数在基类中声明为虚函数，他就一直为虚函数，派生类无法改变该函

数为虚函数这一事实。派生类重定义虚函数时，可以使用virtual保留字名，但这不必须。

    4.派生类对象包含基类对象作为子对象:派生类由本身定义的成员加上基类定义的成员组成。

    5.派生类中的函数可以使用基类的成员。

类可以访问其基类的public和protected成员，就好像那些成员是派生类自己的成员一样。

    6.用作基类的类必须是已定义的。

    7.派生类也可以做基类。
    
    8.如果需要声明一个派生类，则声明包含类名但不包含派生列表。

class Bulk_item:public Item_base;    // error
class Bulk_item;    //right
class Item_base;    //right

*******************************************************************

15.virtual与其他成员函数

    动态绑定两个条件：

        1.只有指定为虚函数的成员才能动态绑定。

        2.必须通过基类类型的引用或指针进行函数调用。


  在运行时确定virtual函数的调用，在编译时确定非virtual函数的调用。
         
  覆盖虚函数机制:

    在某些情况下希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，这时可以

使用作用域操作符：

   Item_Base *baseP = &derived;

   double d = baseP->Item_base::net_price(42);

***只有成员函数中的代码才应该使用作用域操作符覆盖虚函数机制。派生类虚函数调用

基类版本时，必须显式使用作用域操作符。      


   虚函数与默认实参：

        虚函数可以有默认实参。通过基类的引用或指针调用虚函数时，默认实参为在基类虚函数声明中指定的值。

                              通过派生类的引用或指针调用虚函数时，默认实参是在派生类的虚函数声明中指定的值。

        *** 通过基类的引用或指针调用虚函数，但实际执行的是派生类中定义的版本，会有问题。

        *** 这时为基类版本定义的默认实参将传递给派生类定义的版本。

        *** 也就是说调用派生类的版本，默认参数是基类的版本。


公用、私有和受保护的继承

    1.每个类控制它所定义的成员的访问。派生类可以进一步限制但不能放松对所继承的成员的访问。

    如果是public继承，基类成员保持自己的访问级别。

    如果是protected继承，基类的public和protected成员在派生类中为protected成员。

    如果是private继承，基类的所有成员在派生类中为private成员。

    2.派生类可以恢复继承成员的访问级别。

        class Derived : private Base{
            public:
                using Base::size;  //在base中是public;
            protected:
                using Base::n;  //在base中是public;

        }

    3.默认继承保护级别：

        class Base {    }

        struct D1:Base{    }    // 默认public继承

        class D2:Base{    }    // 默认private继承


友元关系与继承:

    像其他类一样，基类或派生类可以使其他类或函数成为友元。友元可以访问类的private和protected数据。

基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，该基类的派生类不能访问授予友元

关系的类。

继承与静态成员：

    如果基类定义了static成员，则整个继承层次中只有一个这样的成员。无论从基类派生出多少类，只有一个

static成员实例。

    
********************************************

转换与继承

    派生类的地址或对象可以对基类的指针或引用赋值或初始化。

    对对象严格来讲不会自动将派生类型对象转换为基类类型的对象。

1.引用转换不同于转换对象。

    用派生类对象对基类对象进行初始化或赋值。

    Item_base item;    // base type
    Bulk_item bulk;    // derived type

    Item_base item(bulk);    // sliced down to its Item_base portion
    item = bulk;    // bulk is sliced down to its Item_base portion

    基类一般(显示或隐式）定义自己的复制构造函数和赋值操作符，这些成员接收一个形参，

该形参是基类类型的引用。因为存在从派生类到基类引用的转换，这些复制控制成员可用于从

派生类对象对基类对象进行初始化或赋值。

2.派生类到基类转换的可访问性

    从派生类到基类的转换可能是也可能不是可以访问的。转换是否可访问取决于在派生类的

派生列表中指定的访问标号。

    如果是public继承，则用户代码和后代类都可以使用派生类到基类的转换。

    如果类是使用private或proteted继承，则用户不能将派生类转为基类对象。

无论什么派生访问标号，派生类本身都可以访问基类的public成员。

****************************************************************

1.基类到派生类的转换：从基类到派生类的转换是不存在的。

甚至当基类指针或引用实际绑定到派生类对象时，从基类到派生类的转换也存在限制

   Bulk_item bulk;
   Item_base *itemp = &bulk;    // ok:
   Bulk_item *bulkp = itemP;    // error:

2.派生类构造函数

   派生类的构造函数受继承关系的影响，每个派生类构造函数除了初始化自己的数据

成员之外，还要初始化基类。

   定义默认构造函数。

    class Bulk_item:public Item_base{
        public;
            Bulk_item:min_qty(0),discount(0.0){}  //这个构造函数还隐式调用Item_base的默认构造函数
                                                  //初始化对象的基类部分
    };

3.向基类构造函数传递实参。

    派生类构造函数通过将基类包含在构造函数初始化列表来间接初始化继承成员。

     class Bulk_item:public Item_base
    {
        public:
            Bulk_item(const std::string& book, double sales_price,

                std::size_t qty=0, double disc_rate=0.0):Item_base(book,sales_price),min_qty(qty),
                    discount(dis)

    };


构造函数的初始化列表为基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明

次序初始化派生类的成员。

4.在派生类构造函数中使用默认实参。

    可以使不同个数实参的初始化，使用一个构造函数。

5.只能初始化直接基类。

    一个类只能初始化自己的直接基类。直接基类就是在派生列表中指定的类。
    
*******************************************************

复制控制和继承

    合成操作对对象的基类部分连同派生部分的成员一起进行复制、赋值或撤销。使用基类的复制构造函数、赋值操作符

或析构函数对基类部分进行复制、赋值或撤销。

    类是否需要定义复制控制成员完全取决于类自身的直接成员。基类可以定义自己的复制控制而派生类使用合成版本。

                                                          基类可以使用合成版本而派生类定义自己的版本。

    只包含类类型或内置类型的数据成员、不含指针的类一般可以使用合成操作。
    
1.定义派生类复制构造函数

    如果派生类显式定义自己的复制构造函数或赋值操作符，则改定义将完全覆盖默认定义。被继承类的复制构造函数和

赋值操作符负责对基类成分以及类自己的成员进行复制或赋值。

*** 如果派生类显式定义自己的复制构造函数，该复制构造函数一般应该显式使用基类复制构造函数初始化基类部分。

class Base{};
class Derived:public Base
{
    public:
         Derived(const Derived& d):Base(d){}    //应显示调用基类复制构造函数
};

初始化函数Base(d)将派生类对象d转换为它的基类部分的引用，并调用基类复制构造函数。

2.派生类赋值操作符

    赋值操作符通常与复制构造函数类似：如果派生类定义了自己的复制操作符，则该操作符必须对

基类部分进行显示赋值。

// Base::operator=(const Base&) 

Derived &Derived::operator=(const Derived &rhs)
{
    if(this!=&rhs)
    {
       Base::operator=(rhs);    //显示调用基类的赋值操作符
    }
    return *this;
}

3.派生类析构函数

    析构函数的工作与复制构造函数和赋值操作符不同。派生类析构函数不负责撤销基类对象的成员。

编译器总是显式（我觉得应该是自动）调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。

class Derived : public Base{
    public:
        // Base::~Base 被自动调用
        ~Derived() {}    // 只负责清楚自己的成员
};

对象的撤销顺序与构造顺序相反：首先运行派生类析构函数，然后按继承层次一次向上调用各个基类析构

函数。


4.虚析构函数

    自动调用基类部分的析构函数对基类的设计有重要影响。

    如果删除基类指针，则需要运行基类析构函数并清除基类的成员。如果对象实际是派生类型的，

则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数。

    class Item_base{
        public:
            virtual ~Item_base(){}
    }

    如果析构函数为虚函数，那么通过指针调用时，运行那个析构函数将因指针所指对象类型的不同

而不同。

    Item_base *itemP = new Item_base;
    delete itemP;
    itemP = new Bulk_item;
    delete itemP;

如果基类的析构函数是虚函数，它的派生类无论是自定义还是合成的也都是虚函数。

*** 因此即使析构函数没有工作要做，继承层次的跟类也应该定义一个虚析构函数。


*************************************************************************

    构造函数和复制操作符不是虚函数：构造函数是在对象完全构造之前运行的，在构造函数运行的时候，

对象的动态类型还不完整。

    虽然可以在基类中将成员函数operator=定义为虚函数，但这样做并不影响派生类中使用的赋值操作符。

每个类有自己的赋值操作符，派生类中的赋值操作符有一个与类本身类型相同的形参。该类型在每个继承

层次中都不同。

    *** 将类的赋值操作符定义为虚函数没设么用处。

**************************************************************************

    构造函数和析构函数中的虚函数

    构造和析构函数运行期间对象都是不完整的，对虚函数的绑定有影响。

如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。

    *** 这样的原因是：防止在构造过程中从基类构造函数调用派生类版本。

***************************************************************************

继承情况下的类作用域    

    如果不能在派生类中找到成员名字，就在外围基类作用域中查找改名字的定义。

    Bulk_item bulk;
    cout << bulk.book();    // book() 是基类中的成员.

  1.名字查找在编译时发生。

    对象、引用或指针的静态类型决定了对象能完成的行为。甚至当静态类型和动态类型可能

不同时。
   
    class Dsic_item:public Item_base{
        public:
            std::pair<size_t,double>discount_policy() const
            { return std::make_pair(quantity, discount); }
    };
 
    Bulk_item bulk;
    Bulk_item *bulkP = &bulk;   // ok  
    Bulk_item *itemP = &bulk;   // ok 
    bulkP->discount_policy();   // ok 
    itemP->discount_policy();   // error,只能访问对象的基类部分。

  2.名字冲突与继承

    虽然可以直接访问基类成员，就像他是派生类成员一样，但是成员保留了它的

基类成员资格。通常我们不关心它是否属于基类，除非基类派生类共用一个名字。
 
    与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。

    struct Base { 
        Base():mem(0){} 
        portected:
            int mem;
   };

   struct Derived:Base{
       Derived(int i):mem(i){}
       int get_mem() {return mem;}    //访问的是 Derived中的 mem
       protected:
          int mem;
   };

   使用作用域操作符访问被屏蔽的成员

   struct Derived:base{
       int get_base_mem() {return Base::mem;}
   };


   3.作用域与成员函数

       基类和派生类中使用同一名字的成员函数，其行为与数据成员一样，在派生类作用域中

派生类成员将疲敝基类成员。即使函数原型不同，基类成员也会被屏蔽。

  struct Base{
    int memfcn();
  };

  struct Derived:Base{
    int memfcn(int);
  };

  Derived d; Base b;

  b.memfcn();    // call base
  d.memfcn(10);    //call derived
  d.memfcn();    // error
  d.Base::memfcn();   //ok;

  这类似于：局部作用域中声明的函数不会重载全局作用域中的函数。同样，派生类中定义的函数也

不重载基类中定义的成员。通过派生类对象调用函数是，实参必须与派生类中定义的版本相匹配。只有

派生类找不到该成员时才考虑基类函数。

***********************************************

重载函数

    像其他任意函数一样，成员函数（无论虚还是非虚）也可以重载。派生类可以重定义所继承的0个

或多个版本。

    如果派生类重定义了重载成员，则通过派生类型只能访问派生类中重定义的那些成员。

class Base {  
 public:  
  void print() {  
    cout << "print() in Base." << endl;  
  }  
  void print(int a) {  
    cout << "print(int a) in Base." << endl;  
  }  
  void print(string s) {  
    cout << "print(string s) in Base." << endl;  
  }  
};  


class Derived : public Base {  
 public:  
  using Base::print;    // 加入这一句可以使用基类的所有版本

  void print() {        // 覆盖基类的无参数版本

    cout << "print() in Derived." << endl;  
  }  
};  


4.虚函数与作用域

    名字查找和继承：

    1.首先确定进行函数调用的对象、引用或指针的静态类型。

    2.在该类中查找函数，如果找不到，就在积累中找，一次按继承类网上，

直到找到该函数或查找完最后一个类。如果不能再类或相关基类中找到改名字，

则调用时错误的。

    3.一旦找到了改名字，就进行常规类型建厂，哈坎如果给定找到的定义，

该函数调用是否合法。

    4.假定函数调用喝吧，编译器就生成代码。如果函数是虚函数且通过引用

后指针调用则编译器生成代码以确定根据对象的动态乐行运行那个函数版本。
    
*********************************************************************

纯虚函数

   class Disc_item:public Item_base{
       public:
           double net_price(std::size_t) const = 0;  // = 0,指定为纯虚函数
   };

    将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，

但是这个类中的版本不会调用。重要的是，用户将不能创建Disc_item类型对象。

含有（或继承）一个或多个纯虚函数的类是抽象基类。除了作为抽象基类的派生

类的对象组成部分，不能创建抽象类型的对象。

**********************************************************************

容器与继承

    因为派生类对象在复制给其积累对象时会被“截短”所以容器与通过继承

相关的类型不能很好的融合。

********************************************************************

句柄类与继承：仍需继续了解

    C++中面向对象编程必须使用指针或引用，而不是对象。



















